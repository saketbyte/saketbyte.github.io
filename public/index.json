[{"content":"Contents: Promise.all Promise.allSettled Promise.any Promise.race JavaScript’s Promise.all, Promise.allSettled, Promise.any and Promise.race are essential when managing multiple async operations. But what really happens under the hood? In this post, let us rebuild each from scratch using async/await only and visualize how they interact with the event loop.\nFirst like always a brief refresher of Event loop components.\nComponent Description Call Stack Runs synchronous code one line at a time Web APIs Handles async operations like fetch, setTimeout, etc. Microtask Queue Queues await/.then resolutions Macrotask Queue Queues setTimeout, DOM events, etc. Event Loop Orchestrates moving tasks from queues into the call stack Let us start.\nPromise.all – Fail-Fast-Policy Promise.all shoots all the promises concurrently and gives us the final result in max(T_promise_1,T_promise_2.... T_promise_n) time, but returns immediately as soon as the earliest error/rejection is received.\nUnderstanding the requirements:\nExecution Behaviour : Resolves only when all promises fulfill. Rejects immediately if any promise fails.\nThis kind of behaviour is useful when the final outcome has mandatory dependencies on more than one promises. And even if one of the promise fails, we cannot proceed further. Hence for this kind of fail fast and return logic we use promise.all.\nEdge Cases :\nThe return type should be a promise because user might have to chain it or use await on the response again.\nIf the iterable of promises received is blank then we have to return back blank array.\nThe order of return values stored in returned promise should be the same as that of input respectively.\nThe returned Promise can contain non promise objects.\nImplementation Logic: Check for the edge case of input being empty and once that is cleared we can dive deeper into the code.\nWe can iterate on the iterable using forEach or map if we want to create a new array. We also need to check if we have resolved all promises or not, and break immediately if even one of them fails.\nNote that: forEach is an older functionality which does not utilise asynchronous method so either we wrap it in an asynchronous function or we use an IIFE. Or we can totally avvoid forEach by using map function.\nThis function behaves like if and only if everyone has completed the work the entire class will get a games period, even if one fails, the entire class will not get the reward.\nImplementation (with async/await) // Promise.all() = promiseAll async function promiseAll(promises) { // array to store the result of Promises. const results = []; // Number of resolved Promises to ensure all are resolved before returning. let resolvedCount = 0; // As discussed above we need to return a promise object from the function. return new Promise((resolve, reject) =\u0026gt; { if (promises.length === 0) { resolve(results); return; } // iterating through each promise index-wise in same order. promises.forEach((p, index) =\u0026gt; { // Used an async IIFE here, but an async func or map can be used too // IIFE is called inside forEach separately for each Promise to make it async. // forEach(async (p,idx)) won\u0026#39;t work it is like a for loop which does not wait for any callback to finish. (async () =\u0026gt; { try { const val = await p; results[index] = val; resolvedCount++; if (resolvedCount === promises.length) { resolve(results); } } catch (err) { reject(err); // Immediately reject on first failure } })(); }); }); } const output = await promiseAll([Promise.resolve(\u0026#34;A\u0026#34;), Promise.resolve(\u0026#34;B\u0026#34;), Promise.resolve(\u0026#34;C\u0026#34;)]); // ➝ [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] // OR - promiseAll([apiCall1(), apiCall2(), apiCall3()]).then((results) =\u0026gt; {}); output.map(() =\u0026gt; { // do something }); await promiseAll([ Promise.resolve(\u0026#34;X\u0026#34;), Promise.reject(\u0026#34;Y\u0026#34;) // ➝ throws \u0026#34;Y\u0026#34; ]); What would a map based iteration look like in above case? // Note the async keyword here allows us to skip asynch IIFE or named function inside it. promises.map(async (p, index) =\u0026gt; { try { const val = await p; results[index] = val; resolvedCount++; if (resolvedCount === promises.length) { resolve(); } } catch (err) { reject(err); } } Promise.allSettled – Record everything Promise.allSettled() is a beautiful function which will come to you after all the promises are settled, either rejected or resolved doesn\u0026rsquo;t matter. But they will have arrived in their final state before coming to you. This is mainly used when the results required are not mandatory, like get all that you can for now, dont care about rejection.\nUnderstanding the requirements:\nExecution Behaviour : Waits for all promises to finish, regardless of success or failure. Returns an array with status and corresponding value or reason.\nEdge Cases and logic:\nMust wait for all promises to settle ie iether resolved(fulfilled) or rejected. Empty input must return back empty output. The result is an array of JS objects which contain status and value for sucess and status and reason for failure. Promise.allSettled is like a teacher asking has everyone settled or not, it does not matter if the homework of students is finished or not. Just settle down!\nImplementation async function promiseAllSettled(promises) { const results = new Array(promises.length); // creating a new promise await new Promise((resolve) =\u0026gt; { let settledCount = 0; // looping over the promises iterable promises.map(async (p, index) =\u0026gt; { try { const val = await p; // recording the results in same order results[index] = { status: \u0026#34;fulfilled\u0026#34;, value: val }; } catch (err) { results[index] = { status: \u0026#34;rejected\u0026#34;, reason: err }; } finally { settledCount++; // sanity check for count of promises if (settledCount === promises.length) { resolve(); } } }); }); return results; } const result = await promiseAllSettled([Promise.resolve(\u0026#34;OK\u0026#34;), Promise.reject(\u0026#34;Failed\u0026#34;)]); console.log(result); // [ // { status: \u0026#34;fulfilled\u0026#34;, value: \u0026#34;OK\u0026#34; }, // { status: \u0026#34;rejected\u0026#34;, reason: \u0026#34;Failed\u0026#34; } // ] Promise.any – Any earliest fulfillment Execution Behaviour: This function Resolves with the first fulfilled promise and will Reject only if all Promises fail. Basically checking the OR of settled states of all promises where fulfilled is T and rejected is F.\nSo if we have p1 and p2 (assume both resolve), in sequence given to promise.any, it will immediately return p1 as resolved.\nEdge cases and logic:\nEmpty input should have an empty array in returned promise. Return at the first success. Reject if all rejected. Think of it like, if a teacher has forgotten her red pen today, and she asks if any student has a red pen. If none of the students answer, the Promise fails, if even one has it, the job is done.\nasync function promiseAny(promises) { const errors = new Array(promises.length); await new Promise((resolve, reject) =\u0026gt; { let rejectedCount = 0; promises.map(async (p, index) =\u0026gt; { try { const val = await p; resolve(val); // resolves first success } catch (err) { errors[index] = err; rejectedCount++; if (rejectedCount === promises.length) { reject(new AggregateError(errors, \u0026#34;All promises rejected\u0026#34;)); } } }); }); } const result = await promiseAny([Promise.reject(\u0026#34;A\u0026#34;), Promise.reject(\u0026#34;B\u0026#34;), Promise.resolve(\u0026#34;C\u0026#34;)]); // ➝ \u0026#34;C\u0026#34; //If all fail: await promiseAny([Promise.reject(\u0026#34;X\u0026#34;), Promise.reject(\u0026#34;Y\u0026#34;)]); // throws AggregateError: All promises rejected Promise.race – Any earliest settlement Execution Behaviour : Resolves or rejects as soon as the first promise settles does not matter fulfilled or rejected. Gives the output from the fastest settlment.\nEdge case and logic :\nDo not confuse this with Promise.all(). In case of failure of a promise, it will return immediately just like Promise.all(), but in case of fulfillment of a promise, Promise.all() will look for other promises\u0026rsquo; result while Promise.race will return with that also.\nThis helps us to pick the fastest results of all.\nasync function promiseRace(promises) { return new Promise((resolve, reject) =\u0026gt; { // using for of to account for non promise objects. for (const p of promises) { (async () =\u0026gt; { try { const val = await Promise.resolve(p); resolve(val); } catch (err) { reject(err); } })(); } }); } const result = await promiseRace([new Promise((res) =\u0026gt; setTimeout(() =\u0026gt; res(\u0026#34;Fast\u0026#34;), 100)), new Promise((res) =\u0026gt; setTimeout(() =\u0026gt; res(\u0026#34;Slow\u0026#34;), 500))]); // \u0026#34;Fast\u0026#34; Summary of all 4 functions so far: Function fulfills rejects Settled on Output Promise.all all fulfill any one rejects Last to fulfill (if all) Array of values in order Promise.allSettled Never Never After all settle Array of {status, value/reason} Promise.any first fulfills all reject First to fulfill or all Value of first fulfilled, else error Promise.race first to settle fulfills first to settle rejects First to settle Value or reason of first to settle Fun analogy to remember the behaviours: Function Teacher’s Promise Rule Promise.all “If even one student has not completed the homework, no reward for entire class, rejected.” Promise.allSettled “Every student\u0026rsquo;s record is tracked. No conclusion of failed or settled.” Promise.any “I just need one student to give me a red pen?” Promise.race “Whichever student tries to share their thought process/answer first.” ","permalink":"https://saketbyte.github.io/posts/promise.all-implementation/","summary":"\u003ch2 id=\"contents\"\u003eContents:\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003ePromise.all\u003c/li\u003e\n\u003cli\u003ePromise.allSettled\u003c/li\u003e\n\u003cli\u003ePromise.any\u003c/li\u003e\n\u003cli\u003ePromise.race\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eJavaScript’s Promise.all, Promise.allSettled, Promise.any and Promise.race are essential when managing multiple async operations. But what really happens under the hood? In this post, let us rebuild each from scratch using async/await only and visualize how they interact with the event loop.\u003c/p\u003e\n\u003cp\u003eFirst like always a brief refresher of Event loop components.\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eComponent\u003c/th\u003e\n          \u003cth\u003eDescription\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eCall Stack\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eRuns synchronous code one line at a time\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eWeb APIs\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eHandles async operations like \u003ccode\u003efetch\u003c/code\u003e, \u003ccode\u003esetTimeout\u003c/code\u003e, etc.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eMicrotask Queue\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eQueues \u003ccode\u003eawait\u003c/code\u003e/\u003ccode\u003e.then\u003c/code\u003e resolutions\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eMacrotask Queue\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eQueues \u003ccode\u003esetTimeout\u003c/code\u003e, DOM events, etc.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eEvent Loop\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eOrchestrates moving tasks from queues into the call stack\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eLet us start.\u003c/p\u003e","title":"Promise Aggregator Functions Implementation"},{"content":"Compare Deeply Nested Objects in JS This is a frequently asked question in interviews for Frontend or in general roles where you are expected to work in Javascript.\nI will go through each and every step which is required for a beginner to understand all the concepts required to tackle this or any deviation of the question. I was asked the question in my first interview of job switch, and I messed it up by figuring out all the logic during interview, never having seen this earlier. I do not want that to happen to me or my readers again. 😇\nTable of Contents: Objects in JS Why this is even needed? Nesting is not the only challenge. Recursive and Iterative approach. Slight deviation - track the changes. Objects in JS Objects store a collection of data. It is most often the format of JSON responses and requests in api calls that is why it is so important to know how to play with these. It will have some key-value pairs, methods as properties, passed as reference(keep this in mind), can show properties of inheritance based on the proptotype.\nWhy do we need such a function? In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true. Hence even if 2 objects are storing exactly same data, if their memory reference is not same,the comparison will yield false.\n// source: developer.mozilla.org // Two variables, two distinct objects with the same properties const fruit = { name: \u0026#34;apple\u0026#34; }; const anotherFruit = { name: \u0026#34;apple\u0026#34; }; fruit == anotherFruit; // return false fruit === anotherFruit; // return false // Two variables, a single object const fruit = { name: \u0026#34;apple\u0026#34; }; const anotherFruit = fruit; // Assign fruit object reference to anotherFruit // Here fruit and anotherFruit are pointing to same object fruit == anotherFruit; // return true fruit === anotherFruit; // return true fruit.name = \u0026#34;grape\u0026#34;; console.log(anotherFruit); // { name: \u0026#34;grape\u0026#34; }; not { name: \u0026#34;apple\u0026#34; } Nesting is not the only challenge Now that it is clear there is a need to have a deepCompare function to check the equality of objects, we need to understand our requirements better. Deeply nested objects can always have a different kind of structure, nesting and data types, so we must have a robust function which does not have nested structure as it\u0026rsquo;s dependency, otherwise it will be hard-coded and fail every now and then. The object can have immense nesting, based on the api call or any other requirement, so we need to make sure we have optimised our approach as well.\nWE cannot just compare with ===. It should be independent of the structure of object nesting. It should be independent of the data types being used either primitive or user defined. (This requires many checks to be added in the iterative version.) Return type is boolean, and takes in 2 objects. Use early return logic so that we do not compare rest of the part as soon as difference is pointed out or equality is guaranteed. Recursive Approach for deep compare: Early return logic: Think of it like base cases What could be the factors which can lead us to certainty of our result:\nIf the reference address of both objects are same - TRUE as it means it is pointing to the same memory. a===b ? handle reference equality\nCheck if either of the objects are null, if so return if a===b again. handle null\nCheck if either of the object is not of same type or not. handle typer mismatch\nNow once we are sure that both the arguments have Object as it\u0026rsquo;s type, we can firstly extract the keys from both, and check if the keys are same in number or not.\nWhen we are sure that both args are objects and have same number of keys, we can pull up the socks and get started with deeper comparison of objects.\nNow that we have our early return/ base cases ready, we can check for rest of the cases which might be present. What checks should be there? As we know there are so many configurations an object can have, it is best to ask the interviewer if they can provide a sample JSON or object structure that needs to be compared.\nExample - All primitive Types, Set, Date, Map, Symbols, Arrays, Objects, Functions etc.\nLet us go through these checks one by one: There could be other kind of data types configuring our object which I have not included here, but the point is, refer the documentation for correct way of comparison of these objects as some have key-value pairs, some methods return non-iterable lists which will break the code. Instead we need to define custom comparison checks for each case.\na. Date -\nif (a instanceof Date \u0026amp;\u0026amp; b instanceof Date) return a.getTime() === b.getTime(); b. RegExp -\nif (a instanceof RegExp \u0026amp;\u0026amp; b instanceof RegExp) return a.source === b.source \u0026amp;\u0026amp; a.flags === b.flags; c. function reference based comparison.\nif (typeof a === \u0026#34;function\u0026#34; || typeof b === \u0026#34;function\u0026#34;) return a === b; Note that we can also compare using Stringify, but that would be a text based comparison, if one of the functions is arrow function but gives same output or something, it will return false. Not a good practise and tricky to compare functions in objects.\nd. Set\nif (a instanceof Set \u0026amp;\u0026amp; b instanceof Set) { if (a.size !== b.size) return false; for (const val of a) if (!b.has(val)) return false; return true; } e. Map\nif (a instanceof Map \u0026amp;\u0026amp; b instanceof Map) { if (a.size !== b.size) return false; for (const [key, val] of a) { // if the key is not present in b or if it is a nested map value (Note there is a recursive call explained later) if (!b.has(key) || !deepCompare(val, b.get(key))) return false; } return true; } Nota Bene How do you correctly extract the Keys of an object or an array?\nThere are several methods inbuilt in JS to achieve the functionality, but we have to pick according to our usecase which is independent of types and easy to traverse (enumerate or iterate). Object.keys(), Object.getOwnPropertyname(), Reflect.ownKeys() etc.\nBut what is Enumerable vs Iterable?\nEnumerable A property is enumerable if it shows up during property enumeration like for\u0026hellip;in or Object.keys(). Objects are enumerable only and not iterable.\nWe can check via: Object.getOwnPropertyDescriptor(obj, \u0026lsquo;key\u0026rsquo;).enumerable\nIterable An object is iterable if it implements the Symbol.iterator method. We can use for\u0026hellip;of on iterables.\nArrays are both enumerable (via indices) and iterable (via values).\nExamples: Arrays, Strings, Maps, Sets, array.keys(), array.entries()\nThink of a big cupboard with many drawers lined up in it. And some people like to organise the drawers by pasting a name below the door handle. This makes the otherwise \u0026ldquo;iterable\u0026rdquo; drawer \u0026ldquo;enumerable\u0026rdquo; now. The named drawer can be quickly accessed, someone can say - \u0026ldquo;Get me the blue colored medicine from the medicine drawer.\u0026rdquo; and another way would be without those labels - \u0026ldquo;Check the cupboard and get me the blue colored medicine please?\u0026rdquo;. In the second case we will be iterating through the drawers and accessing the info, while in the first case, we had it enumerable.\nTechnically speaking, [Symbol.iterator] is added to an enumerable object to make it iterable. It is a generator function which will yield the value one by one.\nconst obj = { a: 10, b: 20, c: 30, [Symbol.iterator]: function* () { for (const key of Object.keys(this)) { yield this[key]; } } }; for (const value of obj) { console.log(value); // Output: 10, 20, 30 } Methods which are specific only to arrays can be:\n// using in-built functions for arrays Object.keys(array); array.keys(); Array.prototype.entries(); //using for in loop for (let idx in array) { // continue } Methods specific to Objects only would be:\n// using in-built functions for Objects Object.keys(obj); Object.getOwnPropertyNames(obj); Object.getOwnPropertySymbols(obj); // Only symbol keys Reflect.ownKeys(obj); // Gets all property keys even non-ennumerable and includes a length key. // using for loop for (let key in obj) { //continue } Okay just tell me what to use? Method Works on Object Works on Array Includes Symbol Keys Includes Non-Enumerable Keys Object.keys() Yes Yes No No Object.getOwnPropertyNames() Yes Yes No Yes Reflect.ownKeys() Yes Yes Yes Yes for...in Yes Yes No No (but includes inherited values too.) (Inherited values? It also includes keys inherited from its prototype if they are enumerable.)\nconst parent = { inheritedKey: \u0026#34;hello\u0026#34; }; const child = Object.create(parent); child.ownKey = \u0026#34;world\u0026#34;; for (let key in child) { console.log(key); // Op \u0026#34;ownKey\u0026#34;, \u0026#34;inheritedKey\u0026#34; } console.log(Object.keys(child)); //Op [\u0026#34;ownKey\u0026#34;] As I mentioned we want things to be independent of types as much as possible so that the code stays robust and also does not leave out anything crucial. Hence we end up with the choice of Reflect.ownKeys(), because it allows us to have an enumerable array of keys which we can iterate and it works on both types array or Object both while including inherited keys and Symbols too.\nf. Arrays\nif (Array.isArray(a) \u0026amp;\u0026amp; Array.isArray(b)) { if (a.length !== b.length) return false; for (let i = 0; i \u0026lt; a.length; i++) { // compare here } return true; } g. Generic object (Will have to recur due to possibility of nesting):\n// Generic Object comparison (plain objects, class instances) if (typeof a === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; typeof b === \u0026#34;object\u0026#34;) { if (a.constructor !== b.constructor) return false; const keysA = Reflect.ownKeys(a); const keysB = Reflect.ownKeys(b); if (keysA.length !== keysB.length) return false; for (const key of keysA) { if (!keysB.includes(key)) return false; if (!deepCompare(a[key], b[key])) return false; } return true; } // Fallback for unmatched types or values return false; In above cases we have our transition cases/other checks written correctly, we can think about how do we traverse in an object which is present inside another object, this is like recursive structure. And we can call the function on it\u0026rsquo;s branches and return from there. As soon as we expect branching of the next nested object start, we make a recursive call at that point. Putting this all together: function deepCompare(a: any, b: any): boolean { // Deep Equality comparison by reference if (a === b) return true; // Handle NaN value if (typeof a === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; typeof b === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; isNaN(a) \u0026amp;\u0026amp; isNaN(b)) return true; // Handle null value if (a === null || b === null) return a === b; // Type mismatch in objects if (typeof a !== typeof b) return false; // Logical cases based on data types: // Handle Date if (a instanceof Date \u0026amp;\u0026amp; b instanceof Date) return a.getTime() === b.getTime(); // Handle RegExp if (a instanceof RegExp \u0026amp;\u0026amp; b instanceof RegExp) return a.source === b.source \u0026amp;\u0026amp; a.flags === b.flags; // Handle Functions: compare by reference if (typeof a === \u0026#34;function\u0026#34; || typeof b === \u0026#34;function\u0026#34;) return a === b; // Handle Set if (a instanceof Set \u0026amp;\u0026amp; b instanceof Set) { if (a.size !== b.size) return false; for (let item of a) { if (![...b].some((el) =\u0026gt; deepCompareIterative(el, item))) return false; } continue; } } // Handle Map - recursive call as nesting can occur if (a instanceof Map \u0026amp;\u0026amp; b instanceof Map) { if (a.size !== b.size) return false; for (const [key, val] of a) { if (!b.has(key) || !deepCompare(val, b.get(key))) return false; } return true; } // Generic Object comparison (plain objects, class instances) if (typeof a === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; typeof b === \u0026#34;object\u0026#34;) { if (a.constructor !== b.constructor) return false; const keysA = Reflect.ownKeys(a); const keysB = Reflect.ownKeys(b); if (keysA.length !== keysB.length) return false; for (const key of keysA) { if (!keysB.includes(key)) return false; if (!deepCompare(a[key], b[key])) return false; } return true; } // Fallback for unmatched types or values return false; // Arrays - recursive call as nesting can occur if (Array.isArray(a) \u0026amp;\u0026amp; Array.isArray(b)) { if (a.length !== b.length) return false; for (let i = 0; i \u0026lt; a.length; i++) { if (!deepCompare(a[i], b[i])) return false; } return true; } return false; } Iterative Approach for deep compare: An iterative deep comparison avoids recursion by using an explicit stack (or queue) to simulate the call stack. Instead of calling deepCompare recursively on each nested object or array, we maintain a stack of comparison tasks — each representing a pair of values (a, b) that need to be compared.\nSince recursive stack is not maintained, we have to mimic the functionality by using a stack.\nTo mimic first function call, initialize a stack with the root pair.\nWhile the stack is not empty:\na. Pop a pair from the stack.\nb. Apply all the definitive checks on a and b like - reference comparison, type comparison, object comparison, number of keys comparison etc, if they mismatch, return false.\nc. Otherwise, push all corresponding nested pairs into the stack for comparison in the next iteration mimic further function calls in the order of which they popped from stack.\nfunction deepCompareIterative(a, b) { const stack = [[a, b]]; while (stack.length \u0026gt; 0) { const [val1, val2] = stack.pop(); // Fast path for identical primitives or references if (val1 === val2) continue; // NaN equality if (typeof val1 === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; typeof val2 === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; isNaN(val1) \u0026amp;\u0026amp; isNaN(val2)) continue; // Type mismatch or nulls if (typeof val1 !== typeof val2 || val1 === null || val2 === null) { return false; } // Dates if (val1 instanceof Date \u0026amp;\u0026amp; val2 instanceof Date) { if (val1.getTime() !== val2.getTime()) return false; continue; } // RegExp if (val1 instanceof RegExp \u0026amp;\u0026amp; val2 instanceof RegExp) { if (val1.source !== val2.source || val1.flags !== val2.flags) return false; continue; } // Functions (by reference only) if (typeof val1 === \u0026#34;function\u0026#34; || typeof val2 === \u0026#34;function\u0026#34;) { if (val1 !== val2) return false; continue; } // Sets if (val1 instanceof Set \u0026amp;\u0026amp; val2 instanceof Set) { if (val1.size !== val2.size) return false; for (let item of val1) { if (![...val2].some((el) =\u0026gt; deepCompareIterative(el, item))) return false; } continue; } // Maps if (val1 instanceof Map \u0026amp;\u0026amp; val2 instanceof Map) { if (val1.size !== val2.size) return false; for (let [key, value] of val1) { if (!val2.has(key)) return false; stack.push([value, val2.get(key)]); } continue; } // Arrays if (Array.isArray(val1) \u0026amp;\u0026amp; Array.isArray(val2)) { if (val1.length !== val2.length) return false; for (let i = 0; i \u0026lt; val1.length; i++) { stack.push([val1[i], val2[i]]); } continue; } // Generic Objects (plain objects or class instances) if (typeof val1 === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; typeof val2 === \u0026#34;object\u0026#34;) { if (val1.constructor !== val2.constructor) return false; const keys1 = Reflect.ownKeys(val1); const keys2 = Reflect.ownKeys(val2); if (keys1.length !== keys2.length) return false; for (const key of keys1) { if (!keys2.includes(key)) return false; stack.push([val1[key], val2[key]]); } continue; } // Primitive inequality fallback return false; } return true; } I hope the concept is clear now. Try writing down the code by hand on a piece of paper. I always do that to make sure I am able to recall the core conepts and some of the syntax to bring fluidity in my code writing.\nSlight Deviation Question How would you return the actual changes at the same level of nesting instead of mere true and false?\n(Hint: Memoisation method in Recursive approach!)\nThank you for reading!\n","permalink":"https://saketbyte.github.io/posts/deepcompare/","summary":"\u003ch1 id=\"compare-deeply-nested-objects-in-js\"\u003eCompare Deeply Nested Objects in JS\u003c/h1\u003e\n\u003cp\u003eThis is a frequently asked question in interviews for Frontend or in general roles where you are expected to work in Javascript.\u003c/p\u003e\n\u003cp\u003eI will go through each and every step which is required for a beginner to understand all the concepts required to tackle this or any deviation of the question. I was asked the question in my first interview of job switch, and I messed it up by figuring out all the logic during interview, never having seen this earlier. I do not want that to happen to me or my readers again. 😇\u003c/p\u003e","title":"Compare Deeply Nested JS objects Interview Question"},{"content":"Table of Contents Hoisting Hoisting Behavior Scope Related Behaviour of Variables Temporal Dead Zone Fun Question Summary Hoisting (Bubble up and fill in the fragrance of undefined! XD)\nIn JavaScript, hoisting refers to the behavior where variable declarations are moved to the top of their containing scope—either function or block—during the compilation phase. However, how this hoisting occurs differs significantly between var, let, and const.\nHoisting Behavior of variables var Variables Variables declared using var are hoisted and initialized with undefined. This means that even if you try to access the variable before its declaration, the code won\u0026rsquo;t throw an error; instead, you\u0026rsquo;ll get undefined.\nconsole.log(x); // undefined var x = 10; let and const Variables Unlike var, variables declared with let and const are also hoisted, but they are not initialized during hoisting. Attempting to access them before their actual declaration will result in a ReferenceError.\nconsole.log(x); // ReferenceError: Cannot access \u0026#39;x\u0026#39; before initialization let x = 10; This behavior is due to the Temporal Dead Zone (TDZ), a concept introduced in ES6 to make JavaScript behavior more predictable and reduce the likelihood of bugs.\nScope Related Behavior of variables Scope is not just about accessibility of a variable, but we also need to check lifetime, environment and bindings of the given variable in JS.\nType Narrowest Scope it can exhibit Meaning Reassignment var function available through out the function even if declared within a block ({ }) inside it. Yes let block Not available beyond the block ({ }) in which it is defined. Yes const block Not available beyond the block ({ }) in which it is defined. Mutable but cannot be reassigned. If we declare them in the global scope, let and const (and class) will also create global declarations that is why I have mentioned narrowest scope it can exhibit. Where this gets confusing is, unlike var and function, when let, const, and class are used in the global scope, they do not create global properties, whereas var and function do.\nvar x // global { var y // also global as it can not exhibit the narrow scope of blocks, only of functions. } Remember above and the hoisting concept for the fun question in the end.\nTemporal Dead Zone The Temporal Dead Zone is a period between the start of a block scope and the point where the variable is declared and initialized. During this period, any reference to the variable will throw a ReferenceError.\nKey Characteristics of TDZ: Declaration Phase: When let or const is encountered, the variable is hoisted but left uninitialized. Initialization Phase: The variable gets initialized only when execution reaches the line of declaration. Accessing During TDZ: Accessing the variable before initialization results in a ReferenceError. Example: console.log(x); // ReferenceError let x = 10; In this example, x is hoisted, but not initialized. Trying to log it before the let declaration triggers a ReferenceError because it’s still in the TDZ.\nCoding standards To avoid running into errors caused by the Temporal Dead Zone:\nAlways declare your variables at the top of their scope before using them. Prefer using let and const over var for clearer and more predictable code. Improved Example: let x; // Declare x at the beginning of the scope console.log(x); // undefined (no error) x = 10; // Initialize x In this case, although x is not yet assigned a value at the time of logging, it’s declared properly and no error occurs because it’s not being accessed before the declaration line.\nFun Question: Guess the outputs of the following:\nCode A\nfor (var i = 0; i \u0026lt; 5; i++) { setTimeout(() =\u0026gt; console.log(i), 0); } Code B\nfor (let i = 0; i \u0026lt; 5; i++) { setTimeout(() =\u0026gt; console.log(i), 0); } Answer Remember that var is function scoped, so the same i is shared across all iterations. By the time setTimeout runs, the loop has completed, and i is 3. While let is block scoped, so a new i is created per iteration. Each closure in setTimeout captures the correct value of i at that time.\nWait let me provide some more background information for this:\nClosure A closure is a function that “remembers” the variables from where it was defined, even after that outer scope has finished execution. It is like remembering the taste of chocolate even if it has finished. XD Remember that each function will have an enviornment record in the call stack.\nTake a look at this code:\nfunction chocoPie() { let whiteChocolate = 1; function melted(){ const taste = ++whiteChocolate; return taste; } return melted; } const afterTaste = chocoPie(); // we are storing a reference to the melted function, even when the outer function has completed it\u0026#39;s execution. Above, the execution environment of chocoPie (outer function) is retained as a reference to the melted(inner) function even though the call of chocoPie is done. So we have access to the value of whiteChocolate even after the outer function has completed it\u0026rsquo;s execution. This is called Closure, a combination of function objects which retains the environment in function call stack. Happens in nested functions always.\nNow here, the difference between var and let is not that clear, because whiteChocolate is function scoped for both. Both var and let will pass through this funnel of scope.\nBack to fun question: Note: In code A and code B examples, let is in it\u0026rsquo;s narrowest scope ie block, while var behaves in it\u0026rsquo;s function scope. Hence the difference arises.\nExecution Context : Every time a function runs, a new execution context is created and pushed to the call stack. The execution context includes a Lexical Environment that holds variable bindings.\nLexical Environment : A Lexical Environment is a structure that holds identifiers (variables/functions) and references to outer environments (called the outer environment reference). Think of it like a scope + closure reference.\nBehind the Scences : The for loop code runs first — no setTimeout fires yet. After 0ms, setTimeout callbacks are put into the task queue. When the call stack is empty, each callback is pulled from the queue and executed in its own execution context.\nvar Now var i is hoisted and declared in the global execution context (or function context if inside a function). There is only one i shared by all iterations. Each time setTimeout() is called, a callback function is created, but it closes over the same environment, i.e., the same i. So when the callbacks run, the loop has already completed, and i is now 5. All callbacks log 5, because they all reference the same i from the shared environment.\nlet Unlike var, let is block-scoped. The JavaScript engine treats this for loop as creating a new block-scoped environment for each iteration. For every iteration, a new Lexical Environment is created with a fresh i, unique to that loop iteration. The arrow function passed to setTimeout() closes over that unique environment. So when the callbacks run: Each closure has its own i, so they log 0, 1, 2, 3, 4.\nHomework question: const counter = () =\u0026gt; { let count = 0; return{ increase: (step = 1) =\u0026gt; { count+=step;}, getValue: () =\u0026gt; { return count;}; }; }; // Think about how closures are working in above. Solution:\n// Test like this: const counter = () =\u0026gt; { let count = 0; return { increase: (step = 1) =\u0026gt; { count += step; }, getValue: () =\u0026gt; { return count; } }; }; const f = counter(); f.increase(); console.log(f.getValue()); f.increase(); console.log(f.getValue()); f.increase(); console.log(f.getValue()); // output- 1 2 3 Summary var is hoisted and initialized to undefined. So you can refer to a var variable and it will output undefined. let and const are hoisted but not initialized, leading to a TDZ. So you can refer but it will throw ReferenceError. YES, var, let and const all are hoisted but var is not moved to Temporal Dead Zone. Accessing let or const variables before their declaration throws a ReferenceError. TDZ helps enforce cleaner coding by encouraging early declarations and preventing undefined access. ","permalink":"https://saketbyte.github.io/posts/hoisting-and-scopes/","summary":"\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#hoisting\"\u003eHoisting\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#hoisting-behavior-of-variables\"\u003eHoisting Behavior\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#scope-related-behavior-of-variables\"\u003eScope Related Behaviour of Variables\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#temporal-dead-zone\"\u003eTemporal Dead Zone\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#fun-question\"\u003eFun Question\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#summary\"\u003eSummary\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch1 id=\"hoisting\"\u003eHoisting\u003c/h1\u003e\n\u003cp\u003e(Bubble up and fill in the fragrance of undefined! XD)\u003c/p\u003e\n\u003cp\u003eIn JavaScript, \u003cstrong\u003ehoisting\u003c/strong\u003e refers to the behavior where variable declarations are moved to the top of their containing scope—either function or block—during the compilation phase. However, how this hoisting occurs differs significantly between \u003ccode\u003evar\u003c/code\u003e, \u003ccode\u003elet\u003c/code\u003e, and \u003ccode\u003econst\u003c/code\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"hoisting-behavior-of-variables\"\u003eHoisting Behavior of variables\u003c/h2\u003e\n\u003ch3 id=\"var-variables\"\u003e\u003ccode\u003evar\u003c/code\u003e Variables\u003c/h3\u003e\n\u003cp\u003eVariables declared using \u003ccode\u003evar\u003c/code\u003e are \u003cstrong\u003ehoisted and initialized with \u003ccode\u003eundefined\u003c/code\u003e\u003c/strong\u003e. This means that even if you try to access the variable before its declaration, the code won\u0026rsquo;t throw an error; instead, you\u0026rsquo;ll get \u003ccode\u003eundefined\u003c/code\u003e.\u003c/p\u003e","title":"Hoisting and Scopes"},{"content":"Debounce and Throttle Functionality Definitions: Debounce and Throttle are used to control how often a high frequency event triggers the function call, which will lead to calls to the back-end.\nDebounce ensures that the function is called only after a specified delay has passed since the last time it was invoked. This is commonly used in user inputs for search bar, auto-saving a form, form validation once the user has stopped editing a field etc.\nA debounce function will delay the execution of func() until the user stops triggering it for a specified delay in ms. Like we do not want to call search api at each keystroke.\nThrottle ensures that a function is called at most once in every specified time gap regardless of how many times the event is triggered. Useful for infinite scrolling. So we call the required API once immediately, and then wait for t seconds to pass to allow another call to happen again.\nTip - There are comprehensive implementations in lodash library.\nDebounce - As already mentioned debounce() wraps the api function call, and everytime the api function has to be called, it goes through the debounce function call, and we check if the timer with some ID, has been active already, we reset it, and wait until it get\u0026rsquo;s over to execute our main api function func(). The debounce function will start the timer everytime it is called.\nOverall Logic in Steps: A timeout ID is stored to track scheduled executions.\nEvery time the returned function is called:\na. It clears the previous scheduled execution.\nb. It schedules a new execution after delay ms.\nWhen the delay finishes: func() is invoked with the original this context and arguments.\nCode Example // Debounce Function Implementation // takes in the function on which it should debounce and a default timeout value. function debounce(func, delay) { let timeoutId; return function (...args) { // 1. Clear any previously scheduled fn call clearTimeout(timeoutId); // 2. Set a new timer to call fn after delay timeoutId = setTimeout(() =\u0026gt; { func.apply(this, args); // 3. Call fn with correct context and args }, delay); }; } // Callback version: const debounce = (func, delay) =\u0026gt; { let timeoutId; return (...args) =\u0026gt; { clearTimeout(timeoutId); timeoutId = setTimeout(() =\u0026gt; { func.apply(this, args); // or just: callback(...args); }, delay); }; }; We need to bind/apply this to the function to pass correct this context and correct event.target information to the api call. Also note that since timer ID is unique in itself but not carrying the information to map it to a specific function call, we are not allowed to share the function with multiple api func()s. Each func() should have it\u0026rsquo;s own debounce or modify the debounce by adding key to the timer. But what is going on under the hood? And why do I need to return a function instead of just calling it in callback of setTimeout? This is because debounce does not call func() immediately. It is different from saying - call this func() after delay = 2s, instead it says, take this version of my func() and after delay = 2s, if the timer is not cleared, execute this. Think about it, your args will be different each time.\nReturned Function - Controller This function is crucial to the concept of debouncing, because each function call will create a closure which will contain the returned function from debounce having it\u0026rsquo;s own internal state (timeOut ID and relevant arguments) and manages the call based on timer value. Now it is also clear that why do we need to apply reference of this to our returned function so that it takes the correct execution context with it.\nIncorrect:\ndebounce(console.log(\u0026#34;Hello\u0026#34;), 300); // this is a blunder in the name of debounce Correct:\nconst debouncedLog = debounce(() =\u0026gt; console.log(\u0026#34;Hello\u0026#34;), 300); debouncedLog(); // Will log after 300ms (if not called again in between) It returns a function with a timer, which is asynchronous task and handled by Web API of setTimeout() once that timer is over, it will move the debounced function func() to our callback queue/Macrotask queue, which in correct sequence pushes the function to event loop and call stack with required global/local context to execute func().\n(Prerequisite - Event Loop) A brief refresher:\nComponent Description Call Stack JS code is executed here, synchronously, one at a time Web APIs Provided by the browser (e.g., fetch, setTimeout, etc.) Callback / MacroTask Queue Where async callbacks are queued when ready Microtask Queue Where Promise.then, async/await results go Event Loop Orchestrates execution between stack and queues Few dots you can connect by seeing the diagram above -\nClosure is created and the function is returned with it\u0026rsquo;s unique timer ID and args (called Controller function). The function will enter call stack, web API starts to clock the timer (resets if already existed) and execution is popped off until asynch task of timer is finished. Timer is running in the Web API background and is monitored by Event Loop. Timer is over now, so the event loop pushes the task into callback Queue/macrotask queue. If the call stack is empty or at the right turn, this macro task is executed. Note that if the timer is cancelled by another debounce call, the earlier controller is deleted as the clearTimeout() removes the pending timer from Web API environment, and never passed to the callback queue for execution.\nThrottle Throttle is very similar to above Debounce function. Debounce waits before execution while Throttle waits after one execution.\nOverall Logic in steps The first call goes through.\nThe function sets a flag/timer to block further calls.\nAny calls during the wait period are ignored.\nAfter delay ms, the flag resets, and the function can run again\nUnlike debounce, throttle does not cancel timers. It remembers the last execution time and checks: \u0026ldquo;Has enough time passed since last call?\u0026rdquo;\nfunction throttle(fn, interval = 1000) { let lastTime = 0; return function (...args) { const now = Date.now(); if (now - lastTime \u0026gt;= interval) { lastTime = now; fn.apply(this, args); } }; } // Callback version const throttle = (callback, delay = 1000) =\u0026gt; { let shouldWait = false; return (...args) =\u0026gt; { if (!shouldWait) { callback.apply(this, args); // Or just callback(...args) shouldWait = true; setTimeout(() =\u0026gt; { shouldWait = false; }, delay); } }; }; In above if we make a call to the throttle:\nTime Call to throttledFn() Executes? 0ms Yes (first call) Yes 200ms No (still waiting) No 400ms No No 1000ms Yes (timer expired) Yes Summary Feature Debounce Throttle Purpose Wait until no calls are made Limit execution to every N ms Use Case Input validation, resize Scroll, mousemove Frequency Fires once after final event Fires every interval Behavior Resets timer on each call Ignores calls until interval passes ","permalink":"https://saketbyte.github.io/posts/debounce-and-throttle/","summary":"\u003ch1 id=\"debounce-and-throttle-functionality\"\u003eDebounce and Throttle Functionality\u003c/h1\u003e\n\u003ch2 id=\"definitions\"\u003eDefinitions:\u003c/h2\u003e\n\u003cp\u003eDebounce and Throttle are used to control how often a high frequency event triggers the function call, which will lead to calls to the back-end.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eDebounce\u003c/strong\u003e ensures that the function is called only after a specified delay has passed since the last time it was invoked. This is commonly used in user inputs for search bar, auto-saving a form, form validation once the user has stopped editing a field etc.\u003c/p\u003e","title":"Debounce and Throttle"},{"content":"JavaScript Interview Questions 1: Playing with a typical API response and basic functions in JS const users = [ { id: 1, name: \u0026#34;name1\u0026#34;, premiumUser: true, age: \u0026#34;20\u0026#34; }, { id: 2, name: \u0026#34;name2\u0026#34;, premiumUser: true, age: \u0026#34;40\u0026#34; }, { id: 3, name: \u0026#34;name3\u0026#34;, premiumUser: false, age: \u0026#34;40\u0026#34; }, { id: 4, name: \u0026#34;name4\u0026#34;, premiumUser: false, age: \u0026#34;30\u0026#34; } ]; // Result // [\u0026#39;name1\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;name3\u0026#39;] Interviewer Perspective The interview is looking forward to make you comfortable and testing the waters as to what levels can they go to.\nExtracting Names from above object Using a basic for loop const names = []; for(let i =0;i\u0026lt;user.length;i++) names.push(users[i].name); console.log(\u0026#34;Names: \u0026#34;names); Using forEach const names = []; users.forEach((user) =\u0026gt; { names.push(user.name); }); console.log(names); Using map const names = users.map((user) =\u0026gt; user.name); console.log(names); Let us check some other interesting functions: Filter premium users // forEach const names =[] users.forEach(curr =\u0026gt; { if(curr.premiumUser) names.push(curr.name) }) console.log(names) // Filter the names of the users who have availed premium service const names = users.filter((user) =\u0026gt; user.premiumUser).map(user=\u0026gt;user.name); console.log(user.name); // Notice that in arrow functions it is not mandatory to write return keyword when eliding {}. Sort based on age Any sorting will take a predicate function which gives a simple answer - what makes this larger/smaller/equal. Based on this boolean value, we can sort anything.\n// Refer: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort function compareFn(a, b) { if (a is less than b by some ordering criterion) { return -1; } else if (a is greater than b by the ordering criterion) { return 1; } // a must be equal to b return 0; // normal function in JS function compareAge(u1, u2){ if(u1.age\u0026lt;u2.age) return -1; else if(u1.age\u0026gt;u2.age) return 1; else return 0; } // arrow function format const compareAge = (u1,u2) =\u0026gt; { if(u1.age\u0026lt;u2.age) return -1; else if(u1.age\u0026gt;u2.age) return 1; else return 0; } // Solution with callback as arrow function (Remember sort will mutate the original array) users.sort((user1, user2) =\u0026gt; user1.age \u0026lt; user2.age? -1:1 ); } Sort based on age, filter only premium users, extract their names. // we can chain these operations. const names = users .sort((user1, user2) =\u0026gt; user1.age\u0026lt; user2.age? -1:1 ) .filter((user) =\u0026gt; user.premiumUser) .map(user=\u0026gt;user.name); console.log(user.name); How would you sort objects based on some property? Eg - Sort books name with last name of author.\nconst books = [ {name: \u0026#34;book1\u0026#34;, author: \u0026#34;author A\u0026#34;}, {name: \u0026#34;book2\u0026#34;, author: \u0026#34;author D\u0026#34;}, {name: \u0026#34;book3\u0026#34;, author: \u0026#34;author C\u0026#34;}, {name: \u0026#34;book4\u0026#34;, author: \u0026#34;author B\u0026#34;}, ] books.sort((book1, book2)=\u0026gt;{ // grab last name const lastName1 = book1.author.split(\u0026#34; \u0026#34;)[1]; const lastName2 = book2.author.split(\u0026#34; \u0026#34;)[1]; return lastName1\u0026lt;lastName2? -1:1; }) console.log(books) // Note that sort will always modify original array on which it is applied on. Anatomy of Filter: Taking directly from developer.mozilla.org docs:\nThe array argument is useful if you want to access another element in the array, especially when you don\u0026rsquo;t have an existing variable that refers to the array.\nThe following example first uses map() to extract the numerical ID from each name and then uses filter() to select the ones that are greater than its neighbors.\nconst names = [\u0026#34;JC63\u0026#34;, \u0026#34;Bob132\u0026#34;, \u0026#34;Ursula89\u0026#34;, \u0026#34;Ben96\u0026#34;]; // Using regex to match and extract digits. const greatIDs = names .map((name) =\u0026gt; parseInt(name.match(/\\d+/)[0], 10)) .filter((id, idx, arr) =\u0026gt; { // Without the arr argument, there\u0026#39;s no way to easily access the // intermediate array generated by map function without saving it to a variable. // id is the curr element, idx is the index of that element in arr if (idx \u0026gt; 0 \u0026amp;\u0026amp; id \u0026lt;= arr[idx - 1]) return false; // comparing on the go in the arr we are building if (idx \u0026lt; arr.length - 1 \u0026amp;\u0026amp; id \u0026lt;= arr[idx + 1]) return false; return true; }); console.log(greatIDs); // [132, 96] // The array argument is not the array that is being built. // There is no way to access the array being built from the callback function. Application of reduce function: const arr = [1, 2, 3, 4]; // Basic syntax: // reduce(callback) // reduce(callback(storeInMe, currElement), start value) const total = arr.reduce((acc, curr) =\u0026gt; acc + curr, 0); // here acc is like the sum variable in sum+= arr[i] // Think like - reduce this array, and accumulate the value in acc. // Pick the current element as curr, and perform some // operation on curr and acc. // Starting with an initial val of 0 here. console.log(total); // 10 Understanding Splice function: // Splice is used to modify the original array - insert, delete opertations. // Syntax: // array.splice(starthere, deleteCount, item1, item2, ..., itemN) // startHere - starts to modify consecutively from this element // delete these many from startHere and insert the remaining after it // Remember it need not match delete count with N items, // the x number of elements are deleted and N-x are inserted. const items = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; items.splice(1, 2, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;); // delete 2 and insert remaining console.log(items); // [\u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;,\u0026#39;d\u0026#39;] Finding all users which satisfy a condition: We can use the some method in above requirement. The some() method is an iterative method. It calls a provided callbackFn function once for each element in an array, until the callbackFn returns a truthy value. If such an element is found, some() immediately returns true and stops iterating through the array.\nconst isValExists = (val, users) =\u0026gt; users.some((user) =\u0026gt; user.name === val) // Or see the below example from Mozilla docs where we are trying to check // if the array is strictly increasing or not. // filter takes only positive elements some uses num as current element, // idx as index, and arr to access the array returned // by filter in the intermediate step. const numbers = [3, -1, 1, 4, 1, 5]; const isIncreasing = !numbers .filter((num) =\u0026gt; num \u0026gt; 0) .some((num, idx, arr) =\u0026gt; { // Without the arr argument, there\u0026#39;s no way to easily access the // intermediate array without saving it to a variable. if (idx === 0) return false; return num \u0026lt;= arr[idx - 1]; }); console.log(isIncreasing); // false Implement a range function which takes start, end and generates an array with those values // Method one: Using for loop const genRange = (start, end) =\u0026gt;{ const result = []; for(let i = start, i \u0026lt;=end; i++){ result.push(i); } return result; } // Method two: Using array.keys method const genRange = (start,end) =\u0026gt; { // spreading an array of size e-s+1 keys will give us the value easily, // but we need to map it from 0 to n-1 to a to b hence we use map. return [...Array(end-start+1).keys()].map((item) =\u0026gt; item+start); } // end - start +1 - number of elements inclusive of s and e, // .keys() generates an iterator, and ... unrolls it to 0,1,2,3 etc // .values() will give us undefined as values are not given to any element. // .map() will map it in the right range. // If we do not need to map, we could directly do - // Make an array of keys as values, and then unrolling those values into a new array. // [...[...Array(end-start+1).keys()].values()] // Iterable deep dive about iterators, Array is inherently also an Object in JS: // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols Summary Function Name Basic Syntax One-Line Use Case Mutates Original Array Returns a Value forEach arr.forEach((item, idx, arr) =\u0026gt; { ... }) arr.forEach(item =\u0026gt; console.log(item)) No No map arr.map((item, idx, arr) =\u0026gt; { ... }) arr.map(item =\u0026gt; item.name) No Yes (new array) filter arr.filter((item, idx, arr) =\u0026gt; { ... }) arr.filter(item =\u0026gt; item.age \u0026gt; 30) No Yes (new array) reduce arr.reduce((acc, curr, idx, arr) =\u0026gt; { ... }, initVal) arr.reduce((acc, curr) =\u0026gt; acc + curr, 0) No Yes (single value) sort arr.sort((a, b) =\u0026gt; { ... }) arr.sort((a, b) =\u0026gt; a.age - b.age) Yes Yes (same array) splice arr.splice(start, deleteCount, ...items) arr.splice(1, 2, 'x', 'y') Yes Yes (array of removed items) slice arr.slice(start, end) arr.slice(1, 3) No Yes (new array) some arr.some((item, idx, arr) =\u0026gt; { ... }) arr.some(item =\u0026gt; item.active) No Yes (boolean) every arr.every((item, idx, arr) =\u0026gt; { ... }) arr.every(item =\u0026gt; item.active) No Yes (boolean) find arr.find((item, idx, arr) =\u0026gt; { ... }) arr.find(item =\u0026gt; item.id === 2) No Yes (first matched item or undefined) findIndex arr.findIndex((item, idx, arr) =\u0026gt; { ... }) arr.findIndex(item =\u0026gt; item.id === 2) No Yes (index or -1) flat arr.flat(depth) [1, [2, [3]]].flat(2) No Yes (new flattened array) concat arr1.concat(arr2) arr1.concat(arr2) No Yes (new array) includes arr.includes(value) arr.includes(5) No Yes (boolean) indexOf arr.indexOf(value) arr.indexOf('a') No Yes (index or -1) join arr.join(separator) arr.join(', ') No Yes (string) reverse arr.reverse() arr.reverse() Yes Yes (same array) push arr.push(item) arr.push('new') Yes Yes (new length) fill arr.fill(value, start, end) arr.fill(0, 1, 3) Yes Yes (same array) Array.from Array.from(arrayLike, mapFn?) Array.from('123', Number) No Yes (new array) Array.isArray Array.isArray(value) Array.isArray([1, 2]) No Yes (boolean) 2: null vs undefined Interviewer Perspective How well do you understand type system and usage clarity while handling API responses or default values while error handling.\nAnswer Undefined This is a primitive value, with type as undefined. The variable is declared but not assigned yet. It is set by JS engine automatically.\nnull This is a null value but weirdly it has a type of Object in JS. It is explicitly set to variables manually. Also a falsy value by nature.\nPlease note (lose equality) JS console.log(null == undefined) will return true as both are false values. In essence undefined is a parallel to notion of missing, while null is to empty. In the temporal dead zone, the value of any variable is undefined. ie, declared but not assigned any value but tried to log - it will show undefined.\n3: Write a function multiply(a)(b) which returns product of a and b Interviewer Perspective The interviewer wishes to check your grasp on concept of currying and it\u0026rsquo;s BTS.\nCorrect Answer Currying is a technique in functional programming where a function with multiple arguments is transformed into a sequence of nested functions, each taking a single argument at a time.\nLet me write the code:\nconst multiply = (a) =\u0026gt;{ return (b) =\u0026gt;{ return a*b}; } // OR const multiply = a =\u0026gt; b =\u0026gt; a*b; But what is going on here? We return functions as the result of a function, and to which we pass further parameter values. This can be expanded recursively as well.\nfunction currySum(expectedArgsCount) { const args = []; function curried(...newArgs) { args.push(...newArgs); // If we have enough arguments, compute the sum if (args.length \u0026gt;= expectedArgsCount) { return args.slice(0, expectedArgsCount).reduce((a, b) =\u0026gt; a + b, 0); } // Otherwise, return the curried function again return curried; } return curried; } const sum = currySum(3); console.log(sum(1)(2)(3)); // 6 console.log(sum(1, 2)(3)); // 6 console.log(sum(1)(2, 3)); // 6 console.log(sum(1, 2, 3)); // 6 Need? It can be used in setInputValue or to apply a function on another function, basically Higher Order functions.\nconst hasRole = role =\u0026gt; user =\u0026gt; user.roles.includes(role); const users = [ { name: \u0026#39;Alice\u0026#39;, roles: [\u0026#39;admin\u0026#39;, \u0026#39;user\u0026#39;] }, { name: \u0026#39;Bob\u0026#39;, roles: [\u0026#39;user\u0026#39;] } ]; const admins = users.filter(hasRole(\u0026#39;admin\u0026#39;)); // Alice // Example 2 const getThisPropertyObject = curry((prop, obj) =\u0026gt; obj[prop]); const getAge = get(\u0026#34;age\u0026#34;); const customFilter = curry((fn,val) =\u0026gt; val.map(fn)); customFilter(getAge, [{age:2}]) // 2 4: Shuffle an Array of Objects Interviewer Perspective They probably want to check language and slight algorithmic profficiency.\nCorrect Answer The approach I am using here is to attach one random value to the object in an array, and then sort based on this random value.\nCode Example const shuffler = (input) =\u0026gt; { return input .map(item) =\u0026gt; ({randomVal:Math.random(), inputVal:item}) .sort(item1,item2)=\u0026gt; (item1.randomVal-item2.randomVal) .map((i) =\u0026gt; i.inputVal); // map and attach randomVal property // sort based on the random value distribution // map and remove that random val again. } 5: Behavior of this keyword There can be 3 places where this is used.\nInside a function Inside an Object Inside a Class Inside a nested function in a class 1. Inside a function When we use this inside a Standalone function, in strict mode this would be undefined but in non-strict mode this will refer to the global/window object.\nfunction useOfThis() { console.log(this); } useOfThis(); // window 2. Inside an Object Let us define an object with some properties and a function which uses this to refer to one of these properties. In this case, the this keyword will always refer to the object which calls it. Here chocolateCake.\nconst chocolateCake = { ingredients: [\u0026#34;semolina\u0026#34;, \u0026#34;baking powder\u0026#34;, \u0026#34;cocoa\u0026#34;, \u0026#34;powdered sugar\u0026#34;, \u0026#34;chocolate syrup\u0026#34;, \u0026#34;dry fruits\u0026#34;], steps: \u0026#34;Bake something like you would bake a cake. :)\u0026#34;, cook() { // do something console.log(\u0026#34;Cake is baked using\u0026#34;, this.ingredients); } }; chocolateCake.cook(); // output - Cake is baked using [\u0026#34;semolina\u0026#34;, \u0026#34;baking powder\u0026#34; .....] NOT SO SIMPLE\nconst cookLater = chocolateCake.cook; cookLater(); // this is global or undefined in this case. :) // we have detached the method from its object and storing it as a plain function. // Now cookLater() is called without any object context, so this becomes: // undefined in strict mode or the global object (window) in non-strict mode 3. Inside a Class Method: This is simple, the this keyword will associate itself with the closest object with which it is called.\nclass Cake { constructor(flavor) { this.flavor = flavor; } bake() { console.log(\u0026#34;Oven started... and the smell of\u0026#34;, this.flavor, \u0026#34;cake is coming to you!\u0026#34;); } } const ananas = new Cake(\u0026#34;ananas\u0026#34;); ananas.bake(); 4. A function nested inside a Class Method (Tricky one) In case we have a function nested inside a class function, and we try to call the class function with help of an object, the this keyword will go crazy. It starts to behave like a normal function and so it outputs undefined in strict mode or global object in non-strict mode.\nReason: First let us understand why? The reason this inside a nested function doesn’t refer to the class instance is because this is dynamically bound based on how a function is called, not where it is written unless it’s an arrow function which borrows the scope of it\u0026rsquo;s just outer lexical scope for this.\nclass Cake { constructor() { this.cakeSize = 1; } bake() { function makeVegan() { console.log(\u0026#34;The vegan cake size is \u0026#34;, this.cakeSize); } makeVegan(); } } const veganCake = new Cake(); veganCake.bake(); // Output - The vegan cake size is undefined How to solve? There are three possible methods to resolve it: a. using arrow function or b. defining this_ as this just outside the function c. use .bind()\n//a. Using arrow function bake() { const makeVegan = () =\u0026gt; { console.log(\u0026#34;The vegan cake size is \u0026#34;, this.cakeSize); }; makeVegan(); } //b. Using this_ bake() { const this_ = this function makeVegan() { console.log(\u0026#34;The vegan cake size is \u0026#34;, this.cakeSize); } makeVegan(); } //c. Using .bind() bake() { const makeVegan = () =\u0026gt; { console.log(\u0026#34;The vegan cake size is \u0026#34;, this.cakeSize); }; makeVegan.bind(this)(); } Let us recap: Context this refers to Function window or global / undefined if strict Object method The object itself Class method The class instance Function inside class method Global or undefined (NOT class instance) Arrow function Lexically inherited from parent scope 6: How to Promisify A Callback based Function? Interviewer Perspective Migration from ES5 to ES6 of some older apis which are still needed but do not have async/await implementation requires this as a daily task sometimes to promisify before using it directly.\nCorrect Answer Approach: Goal - to have a function which converts a legacy callback based functions to promise based functions. Implies - return type is a function, and arguments would be legacy callback. Steps for above would be:\nMake a general purpose promisify function which will take a callback and return an equivalent function which mimics async/await behaviour. Within promisify return a function, which takes required arguments for our legacy callback. Within this function, return a promise, in which we can call our legacy callback, and resolve or reject based on it\u0026rsquo;s response. Code Example const promisify = (fn) =\u0026gt; { // Return a new function that wraps `fn` inside a Promise return function (...args) { // Create and return a new Promise return new Promise((resolve, reject) =\u0026gt; { // Call the original function `fn` with all original args // Add a callback as the last argument to handle result/error fn(...args, (err, result) =\u0026gt; { // If there\u0026#39;s an error, reject the Promise if (err) reject(err); // Otherwise, resolve it with the result else resolve(result); }); }); }; }; Let us try to understand how above will be used and the impact it brings to our code:\n// if odd --\u0026gt; Odd Num Error, else Resolved. function onlyEvenNumResolves(num, my_callback) { setTimeout(() =\u0026gt; { if (num % 2 == 1) return my_callback(\u0026#34;Odd Num Error\u0026#34;, null); else my_callback(null, { result: \u0026#34;Resolution achieved!\u0026#34; }); }, 2000); } // Converting this using our promisify const promiseBasedEvenNumResolves = promisify(onlyEvenNumResolves); const runMyPromisifiedFunction = async () =\u0026gt; { let num = 10; try { const result = await promiseBasedEvenNumResolves(num); console.log(\u0026#34;Success\u0026#34;, result); } catch (err) { console.log(\u0026#34;Error: \u0026#34;, err); } }; runMyPromisifiedFunction(); // Concept Explanation Promisify Convert a callback-style function to return a Promise Promise Modern async pattern that lets you write cleaner async code resolve() Marks the Promise as successful reject() Marks the Promise as failed 7: What do you know about sequential and parallel promises? The calls to api are made in asynchronous pattern. Weather one result depends on the other allows us to choose the pattern in which we can make the api calls. If my api call 2 has some dependency on api call 1, I would perform the operations sequentially, otherwise we can opt for parallel execution to improve performance as the calls are independent of each other.\nLet us take example of 2 dummy API one will fetch our user information and other will fetch Orders made by a user information.\nconst fetchUser = () =\u0026gt; { return new Promise((resolve) =\u0026gt; { setTimeout( () =\u0026gt; resolve([ { userId: 1, name: \u0026#34;Alice\u0026#34; }, { userId: 2, name: \u0026#34;Max\u0026#34; } ]), 1000 ); }); }; const fetchOrders = () =\u0026gt; { return new Promise((resolve) =\u0026gt; { setTimeout( () =\u0026gt; resolve([ { userId: 1, OrderId: 101, item: \u0026#34;Laptop\u0026#34; }, { userId: 2, OrderId: 202, item: \u0026#34;Deodorant\u0026#34; } ]), 1500 ); }); }; Since the APIs are independent in logic and syntax as well. We can go for parallel execution. And in that process, Promise.all() function helps us to execute them in parallel.\nconst fetchInParallelAsync = async () =\u0026gt; { const [user, orders] = await Promise.all([fetchUser(), fetchOrders()]); console.log(\u0026#34;Parallel Async:\u0026#34;, { user, orders }); // Takes appx max of all API calls } Or we can opt for sequential execution to see how it is different:\nconst fetchSequentiallyAsync = async =\u0026gt; () { const user = await fetchUser(); const orders = await fetchOrders(); console.log(\u0026#34;Sequential Async:\u0026#34;, { user, orders }); // Takes appx sum of all API calls time. } But since JS is single threaded how are we able to execute something in Parallel? Javascript is single threaded language, so it is not exactly parallel execution on multiple threads. Instead this is concurrency which gives us the illusion of parallel execution. These api network calls, timeouts are offloaded to the browser environment of Web API or Libuv in NodeJS and once the output of these non-blocking operations is ready which is kept track off by the browser environment, we take them back in our call stack of event loop for execution. Remember the following terms:\nComponent Description Call Stack JS code is executed here, synchronously, one at a time Web APIs Provided by the browser (e.g., fetch, setTimeout, etc.) Callback / MacroTask Queue Where async callbacks are queued when ready Microtask Queue Where Promise.then, async/await results go Event Loop Orchestrates execution between stack and queues In this piece of code let us deep dive into the steps which take place when we use Promise.all().\nconst fetchInParallelAsync = async () =\u0026gt; { const [user, orders] = await Promise.all([fetchUser(), fetchOrders()]); console.log(\u0026#34;Parallel Async:\u0026#34;, { user, orders }); } fetchInParallelAsync function enters our call stack, and waits for it\u0026rsquo;s execution by the JS Engine. On it\u0026rsquo;s right time, 2 non-blocking API calls are sent to the WebAPI of browser, which processes the network requests in it\u0026rsquo;s own environment without disturbing our JS Thread. Our thread is free and it can take up the next task as scheduled in the call stack, if the stack is empty only then it goes to Micro task or later macro task queue or if both are empty, it can check in the call stack again. Web API is continously checking if the result of both calls is ready or not. Once it is ready, the Promises are added to the Micro Task queue for execution. JS Engine picks them up, creates a new Promise for promise.All() and sends back the result to us as response of both the apis. Note that we use promise.all() if we want to receive results of all promises whereas, we use promise.allSettled() if we want results of all the APIs whether they return response or error out.\nTime 0ms--\u0026gt; 100ms--\u0026gt; 200ms --\u0026gt; and so on [fetchUser() in call stack] --\u0026gt; Web API handling request --\u0026gt; Done @ 1000ms --\u0026gt; Microtask Queue --\u0026gt; Wait [fetchOrders() in call stack] --\u0026gt; Web API handling request --\u0026gt; Done @ 1500ms --\u0026gt; Microtask Queue --\u0026gt; Wait After ~1500ms --\u0026gt; All microtasks resolved and Event Loop resumes function Now we console.log({ user, orders }) is printed Take a look at the following commonly used Promise handling methods:\nFunction Syntax Description Example Promise.all Promise.all([p1, p2]) Waits for all to resolve; fails on one Parallel API calls Promise.race Promise.race([p1, p2]) Resolves/rejects as soon as one settles Timeout handling Promise.allSettled Promise.allSettled([p1, p2]) Resolves when all settle, never fails Report all outcomes Promise.any Promise.any([p1, p2]) Resolves with first fulfilled, fails if all reject Fastest successful result Promise.resolve Promise.resolve(value) Creates a resolved promise Simulate fulfilled async response Promise.reject Promise.reject(error) Creates a rejected promise Simulate an error ","permalink":"https://saketbyte.github.io/posts/javascript-interview-questions/","summary":"\u003ch1 id=\"javascript-interview-questions\"\u003eJavaScript Interview Questions\u003c/h1\u003e\n\u003ch2 id=\"1-playing-with-a-typical-api-response-and-basic-functions-in-js\"\u003e1: Playing with a typical API response and basic functions in JS\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eusers\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t{ \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;name1\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003epremiumUser\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eage\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;20\u0026#34;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t{ \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;name2\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003epremiumUser\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eage\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;40\u0026#34;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t{ \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;name3\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003epremiumUser\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eage\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;40\u0026#34;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t{ \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;name4\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003epremiumUser\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eage\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;30\u0026#34;\u003c/span\u003e }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Result\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// [\u0026#39;name1\u0026#39;, \u0026#39;name2\u0026#39;, \u0026#39;name3\u0026#39;]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"interviewer-perspective\"\u003eInterviewer Perspective\u003c/h4\u003e\n\u003cp\u003eThe interview is looking forward to make you comfortable and testing the waters as to what levels can they go to.\u003c/p\u003e\n\u003ch3 id=\"extracting-names-from-above-object\"\u003eExtracting Names from above object\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eUsing a basic for loop\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elength\u003c/span\u003e;\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eusers\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e].\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Names: \u0026#34;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003eUsing forEach\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eusers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003eUsing map\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eusers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emap\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e) =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"let-us-check-some-other-interesting-functions\"\u003eLet us check some other interesting functions:\u003c/h2\u003e\n\u003ch3 id=\"filter-premium-users\"\u003eFilter premium users\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-JS\" data-lang=\"JS\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// forEach\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e[]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eusers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecurr\u003c/span\u003e =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecurr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epremiumUser\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epush\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecurr\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Filter the names of the users who have availed premium service\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enames\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eusers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efilter\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e) =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003epremiumUser\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003emap\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e=\u0026gt;\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Notice that in arrow functions it is not mandatory to write return keyword when eliding {}.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"sort-based-on-age\"\u003eSort based on age\u003c/h3\u003e\n\u003cp\u003eAny sorting will take a predicate function which gives a simple answer - what makes this larger/smaller/equal. Based on this boolean value, we can sort anything.\u003c/p\u003e","title":"JavaScript Interview Questions"},{"content":"Samriddh Singh Email: samriddhsingh00@gmail.com LinkedIn: saketbyte Mobile: +91-7018281212 GitHub: github.com/saketbyte Leetcode: saketbyte PDF: Drive\nEducation National Institute of Technology, Hamirpur — Himachal Pradesh, India Bachelor of Technology GPA: 8.85 July 2019 - June 2023\nRelevant Courses: Design and Analysis of Algorithms, Computer Networks, Data Structures and Algorithms\nSkills Summary Languages: JavaScript, Python, C/C++, SQL Tech Stack: ReactJS, Redux, Tailwind CSS, HTML, NodeJS, ExpressJS, MongoDB, Material UI FastAPI Tools: Agile, Docker, Git, Azure, MSSQL, WordPress, Tableau, Hugo, Github Actions Experience Tata Consultancy Services — Chennai, India Software Developer (Full-time) Sep 2023 – Present\nLegacy App Migration – Pharmaceutical US Client Successfully led and migrated 25+ legacy PowerBuilder screens to ReactJS (v18). Integrated 50+ REST APIs (.NET backend with MSSQL), applied RBAC via Azure AD SSO, implemented chunked file uploads (2GB+), Excel/CSV export, and bulk update services. → Impact: Improved performance via lazy loading, memoization, dynamic imports, reducing load time significantly. Bulk upload reduced processing time by 80%, serving 30,000+ users.\nFull Stack Dashboard Web App – US Retail Apparel Client Developed a responsive React + Node.js dashboard with auth (RBAC), Excel/CSV parsing/export, and SQL DB integration. Deployed with PM2 \u0026amp; Apache. → Impact: Enhanced tracking \u0026amp; visibility by 100%, replacing manual spreadsheet processes.\nAgile, Testing, DevOps Worked in Agile using Azure boards, contributed to weekly sprints. Ensured 80%+ test coverage (SonarQube, React Testing Library). Built CI/CD pipelines via YAML.\nIndian Academy of Sciences @ IIT Gandhinagar — Gandhinagar, Gujarat Summer Research Fellow May 2022 – July 2022\nIn-Memory Computation Optimization for CNNs Developed two algorithms in Python to reduce latency and energy to 12.5% of baseline for CNN inference.\nImpact Coded 15 CNNs from scratch and ran 225+ simulations. Resulted in 8× improvement in computational efficiency using Python, matplotlib, seaborn, Intel CACTI.\n💡 Projects Omniblade ReactJS, Tailwind CSS, Webpack, DOM Manipulation Building a Chrome extension currently which provides multi-text clipboard, gemini AI, weather, Wiki, and google search in it\u0026rsquo;s window without having to juggle between tabs. Just one click away.\nE-Commerce Web App ReactJS, NodeJS, ExpressJS, MongoDB, Tailwind CSS Full-featured clone with 50+ components, add-to-cart, payment gateway (PayTM), user signup/login, state managed with Redux.\nNeural Style Transfer using VGG PyTorch, VGG19, GPU-accelerated Built a neural style transfer pipeline using pre-trained VGG19. Tuned hyperparameters and style-content ratios (1:1e5) for 2048×2048 images.\n→ Impact: Blend any content image with artistic styles for creative generation, game textures, marketing visuals.\n📜 Courses and Certifications Technical:\nDeep Learning Specialization (Coursera) Design and Analysis of Algorithms Computer Networks (NPTEL) Non-Technical:\nGuitar Scales and Chord Progressions Social Psychology (Honours) 🧩 Positions of Responsibility Co-convener – English Literature Club, NIT Hamirpur (Jan 2020 – June 2023) Contributed poems, UI designs, coordinated events, hosted stage activities.\nThoughtBook (August 2019 – Present) Blogger with a niche reader base — sharing book summaries, character analysis, psychology research, and poetry.\n","permalink":"https://saketbyte.github.io/posts/resume/","summary":"\u003ch1 id=\"samriddh-singh\"\u003eSamriddh Singh\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eEmail\u003c/strong\u003e: \u003ca href=\"mailto:samriddhsingh00@gmail.com\"\u003esamriddhsingh00@gmail.com\u003c/a\u003e\n\u003cstrong\u003eLinkedIn\u003c/strong\u003e: \u003ca href=\"https://www.linkedin.com/in/saketbyte/\"\u003esaketbyte\u003c/a\u003e\n\u003cstrong\u003eMobile\u003c/strong\u003e: +91-7018281212\n\u003cstrong\u003eGitHub\u003c/strong\u003e: \u003ca href=\"https://github.com/saketbyte/\"\u003egithub.com/saketbyte\u003c/a\u003e\n\u003cstrong\u003eLeetcode\u003c/strong\u003e: \u003ca href=\"https://leetcode.com/u/saketbyte/\"\u003esaketbyte\u003c/a\u003e\n\u003cstrong\u003ePDF\u003c/strong\u003e: \u003ca href=\"https://drive.google.com/drive/folders/1u6sQJhkxPprKNni_veC60CL-tUjXw6wW\"\u003eDrive\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"education\"\u003eEducation\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eNational Institute of Technology, Hamirpur\u003c/strong\u003e — \u003cem\u003eHimachal Pradesh, India\u003c/em\u003e\n\u003cstrong\u003eBachelor of Technology\u003c/strong\u003e\n\u003cstrong\u003eGPA\u003c/strong\u003e: 8.85\n\u003cem\u003eJuly 2019 - June 2023\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRelevant Courses\u003c/strong\u003e: Design and Analysis of Algorithms, Computer Networks, Data Structures and Algorithms\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"skills-summary\"\u003eSkills Summary\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLanguages\u003c/strong\u003e: JavaScript, Python, C/C++, SQL\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTech Stack\u003c/strong\u003e: ReactJS, Redux, Tailwind CSS, HTML, NodeJS, ExpressJS, MongoDB, Material UI FastAPI\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTools\u003c/strong\u003e: Agile, Docker, Git, Azure, MSSQL, WordPress, Tableau, Hugo, Github Actions\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"experience\"\u003eExperience\u003c/h2\u003e\n\u003ch3 id=\"tata-consultancy-services--chennai-india\"\u003eTata Consultancy Services — \u003cem\u003eChennai, India\u003c/em\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eSoftware Developer (Full-time)\u003c/strong\u003e\n\u003cem\u003eSep 2023 – Present\u003c/em\u003e\u003c/p\u003e","title":"Resume"}]